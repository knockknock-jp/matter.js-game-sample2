// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  $(function() {
    var $body, $html, $window, FPS, ID_SCENE_GAME, ID_SCENE_INTRO, ID_SCENE_OUTRO, ID_SOUND_CLICK, ID_SOUND_COUNTUP, ID_SOUND_FAILURE, ID_SOUND_JUMP, Main, OBSTACLE_DURATION_X, OBSTACLE_DURATION_Y, OBSTACLE_HEIGHT, OBSTACLE_WIDTH, PLAYER_HEIGHT, PLAYER_JUMP_FORCE, PLAYER_WIDTH, Panel, SCROLL_SPEED, STAGE_DEPTH, STAGE_HEIGHT, STAGE_WIDTH, Sound, engine, main, onResize, view;
    $window = $(window);
    $html = $("html");
    $body = $("body");
    if (typeof engine === "undefined" || engine === null) {
      engine = {};
    }
    if (typeof view === "undefined" || view === null) {
      view = {};
    }

    /*
    定数
     */
    FPS = 1000 / 30;
    ID_SCENE_INTRO = "id_scene_intro";
    ID_SCENE_GAME = "id_scene_game";
    ID_SCENE_OUTRO = "id_scene_outro";
    SCROLL_SPEED = 5;
    STAGE_WIDTH = 750;
    STAGE_HEIGHT = 750;
    STAGE_DEPTH = 375;
    OBSTACLE_HEIGHT = 750;
    OBSTACLE_WIDTH = 100;
    OBSTACLE_DURATION_X = 300;
    OBSTACLE_DURATION_Y = 200;
    PLAYER_HEIGHT = 49;
    PLAYER_WIDTH = 34;
    PLAYER_JUMP_FORCE = 0.11;
    ID_SOUND_CLICK = "js-soundClick";
    ID_SOUND_FAILURE = "js-soundFailure";
    ID_SOUND_JUMP = "js-soundJump";
    ID_SOUND_COUNTUP = "js-soundCountUp";

    /*
    クラス
     */
    Main = (function() {
      function Main() {
        this._engine = null;
        this._view = null;
        this._panel = null;
        this._sound = null;
        this._currentSceneId = null;
        this._count = 0;
        $body.on("changeSceneEvent", (function(_this) {
          return function(e, data) {
            if (data.id === ID_SCENE_INTRO) {
              if (_this._currentSceneId === ID_SCENE_INTRO) {
                return;
              }
              _this._currentSceneId = ID_SCENE_INTRO;
              _this._engine.setIntroScene();
              return _this._panel.setIntroScene();
            } else if (data.id === ID_SCENE_GAME) {
              if (_this._currentSceneId === ID_SCENE_GAME) {
                return;
              }
              _this._currentSceneId = ID_SCENE_GAME;
              _this._engine.setGameScene();
              _this._panel.setGameScene();
              _this._count = 0;
              _this._panel.setCount(_this._count);
              return $body.trigger("playSoundEvent", [
                {
                  id: ID_SOUND_CLICK
                }
              ]);
            } else if (data.id === ID_SCENE_OUTRO) {
              if (_this._currentSceneId === ID_SCENE_OUTRO) {
                return;
              }
              _this._currentSceneId = ID_SCENE_OUTRO;
              _this._engine.setOutroScene();
              return _this._panel.setOutroScene();
            }
          };
        })(this));
        $body.on("addCountEvent", (function(_this) {
          return function() {
            _this._count = _this._count + 1;
            _this._panel.setCount(_this._count);
            return $body.trigger("playSoundEvent", [
              {
                id: ID_SOUND_COUNTUP
              }
            ]);
          };
        })(this));
        $body.on("playSoundEvent", (function(_this) {
          return function(e, data) {
            if (data.id === ID_SOUND_CLICK) {
              return _this._sound.play(ID_SOUND_CLICK);
            } else if (data.id === ID_SOUND_FAILURE) {
              return _this._sound.play(ID_SOUND_FAILURE);
            } else if (data.id === ID_SOUND_JUMP) {
              return _this._sound.play(ID_SOUND_JUMP);
            } else if (data.id === ID_SOUND_COUNTUP) {
              return _this._sound.play(ID_SOUND_COUNTUP);
            }
          };
        })(this));
        $body.on("updatePositionEvent", (function(_this) {
          return function(e, data) {
            return _this._view.updatePosition(data);
          };
        })(this));
      }

      Main.prototype.start = function() {
        this._engine = new engine.Engine("js-engine");
        this._view = new view.View("js-view");
        this._panel = new Panel();
        this._sound = new Sound();
        return $body.trigger("changeSceneEvent", [
          {
            id: ID_SCENE_INTRO
          }
        ]);
      };

      Main.prototype.onTapScreen = function() {
        if (this._currentSceneId === ID_SCENE_INTRO) {
          return $body.trigger("changeSceneEvent", [
            {
              id: ID_SCENE_GAME
            }
          ]);
        } else if (this._currentSceneId === ID_SCENE_GAME) {
          this._engine.jumpPlayer();
          return this._view.jumpPlayer();
        } else if (this._currentSceneId === ID_SCENE_OUTRO) {
          this._engine.initialize();
          return $body.trigger("changeSceneEvent", [
            {
              id: ID_SCENE_GAME
            }
          ]);
        }
      };

      return Main;

    })();
    engine.Engine = (function() {
      function Engine(element) {
        this._onHit = __bind(this._onHit, this);
        var ceiling, floor;
        this._engine = null;
        this._player = null;
        this._obstacleArr = [];
        this._scrollX = 0;
        this._scrollTotal = 0;
        this._isHit = false;
        this._intervalId = null;
        this._intervalId2 = null;
        this._engine = Matter.Engine.create(document.getElementById(element), {
          render: {
            visible: false
          }
        });
        Matter.Engine.run(this._engine);
        ceiling = Matter.Bodies.rectangle(STAGE_WIDTH / 2, -10, STAGE_WIDTH * 2, 10, {
          isStatic: true
        });
        floor = Matter.Bodies.rectangle(STAGE_WIDTH / 2, STAGE_HEIGHT + 10, STAGE_WIDTH * 2, 10, {
          isStatic: true
        });
        Matter.World.add(this._engine.world, [ceiling, floor]);
        setInterval((function(_this) {
          return function() {
            var obstacle, params, _i, _len, _ref;
            params = {};
            if (_this._player) {
              params.player = {
                x: _this._player.getPositionX(),
                y: _this._player.getPositionY(),
                angle: _this._player.getAngle()
              };
            }
            params.obstacleArr = [];
            _ref = _this._obstacleArr;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              obstacle = _ref[_i];
              params.obstacleArr.push({
                id: obstacle.getId().top,
                x: obstacle.getPositionX(),
                y: obstacle.getPositionY().top
              });
              params.obstacleArr.push({
                id: obstacle.getId().bottom,
                x: obstacle.getPositionX(),
                y: obstacle.getPositionY().bottom
              });
            }
            params.scroll = _this._scrollTotal;
            return $body.trigger("updatePositionEvent", [params]);
          };
        })(this), FPS);
      }

      Engine.prototype.setIntroScene = function() {
        this._engine.enabled = false;
        return this._scrollTotal = 0;
      };

      Engine.prototype.setGameScene = function() {
        this._engine.enabled = true;
        this._player = new engine.Player(this._engine.world);
        this._obstacleArr.push(new engine.Obstacle(this._engine.world));
        this._isHit = false;
        if (this._intervalId) {
          clearInterval(this._intervalId);
        }
        this._intervalId = setInterval((function(_this) {
          return function() {
            var arr, obstacle, _i, _len, _ref;
            _this._scrollX += SCROLL_SPEED;
            _this._scrollTotal += SCROLL_SPEED;
            if (OBSTACLE_DURATION_X < _this._scrollX) {
              _this._scrollX = 0;
              _this._obstacleArr.push(new engine.Obstacle(_this._engine.world));
            }
            arr = [];
            _ref = _this._obstacleArr;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              obstacle = _ref[_i];
              if (obstacle.getPositionX() < -(OBSTACLE_WIDTH / 2 + 100)) {
                obstacle.remove();
                obstacle = null;
              } else {
                obstacle.update();
                arr.push(obstacle);
                if (obstacle.getIsPast(_this._player.getPositionX())) {
                  $body.trigger("addCountEvent");
                }
              }
            }
            return _this._obstacleArr = arr;
          };
        })(this), FPS);
        return Matter.Events.on(this._engine, "collisionStart", this._onHit);
      };

      Engine.prototype.setOutroScene = function() {
        return this._engine.enabled = false;
      };

      Engine.prototype.initialize = function() {
        var obstacle, _i, _len, _ref;
        if (this._player) {
          this._player.remove();
          this._player = null;
        }
        _ref = this._obstacleArr;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          obstacle = _ref[_i];
          obstacle.remove();
        }
        this._obstacleArr = [];
        this._scrollX = 0;
        return this._scrollTotal = 0;
      };

      Engine.prototype.jumpPlayer = function() {
        if (this._isHit) {
          return;
        }
        return this._player.jump();
      };

      Engine.prototype._onHit = function(e) {
        if (this._intervalId) {
          clearInterval(this._intervalId);
        }
        Matter.Events.off(this._engine, "collisionStart", this._onHit);
        this._isHit = true;
        if (this._intervalId2) {
          clearInterval(this._intervalId2);
        }
        this._intervalId2 = setTimeout((function(_this) {
          return function() {
            clearTimeout(_this._intervalId2);
            return $body.trigger("changeSceneEvent", [
              {
                id: ID_SCENE_OUTRO
              }
            ]);
          };
        })(this), 2000);
        return $body.trigger("playSoundEvent", [
          {
            id: ID_SOUND_FAILURE
          }
        ]);
      };

      return Engine;

    })();
    engine.Player = (function() {
      function Player(world) {
        this._world = world;
        this._body = null;
        this._intervalId = null;
        this._body = Matter.Bodies.rectangle(STAGE_WIDTH / 2, (STAGE_HEIGHT / 2) - 100, PLAYER_WIDTH, PLAYER_HEIGHT, {
          isStatic: false,
          density: 0.002,
          frictionAir: 0,
          render: {
            visible: false
          }
        });
        Matter.World.add(this._world, [this._body]);
      }

      Player.prototype.getPositionX = function() {
        return this._body.position.x;
      };

      Player.prototype.getPositionY = function() {
        return this._body.position.y;
      };

      Player.prototype.getAngle = function() {
        return this._body.angle;
      };

      Player.prototype.jump = function() {
        Matter.Body.applyForce(this._body, {
          x: 0,
          y: 1
        }, {
          x: 0,
          y: -PLAYER_JUMP_FORCE
        });
        this._body.render.sprite.texture = "./images/gesso2.png";
        if (this._intervalId) {
          clearTimeout(this._intervalId);
        }
        this._intervalId = setTimeout((function(_this) {
          return function() {
            return _this._body.render.sprite.texture = "./images/gesso.png";
          };
        })(this), 100);
        return $body.trigger("playSoundEvent", [
          {
            id: ID_SOUND_JUMP
          }
        ]);
      };

      Player.prototype.remove = function() {
        return Matter.World.remove(this._world, this._body);
      };

      return Player;

    })();
    engine.Obstacle = (function() {
      function Obstacle(world, x) {
        var durationY, randomY, targetX, targetY;
        this._world = world;
        this._topBody = null;
        this._bottomBody = null;
        this._isPast = false;
        durationY = OBSTACLE_DURATION_Y / 2;
        randomY = Math.floor(Math.random() * (STAGE_HEIGHT - OBSTACLE_DURATION_Y) - ((STAGE_HEIGHT - OBSTACLE_DURATION_Y) / 2));
        targetX = STAGE_WIDTH + (OBSTACLE_WIDTH / 2) + 100;
        targetY = (OBSTACLE_HEIGHT / 2) + (-STAGE_HEIGHT / 2) - durationY + randomY;
        this._topBody = Matter.Bodies.rectangle(targetX, targetY, OBSTACLE_WIDTH, OBSTACLE_HEIGHT, {
          isStatic: true,
          render: {
            visible: false
          }
        });
        targetY = (OBSTACLE_HEIGHT / 2) + (STAGE_HEIGHT / 2) + durationY + randomY;
        this._bottomBody = Matter.Bodies.rectangle(targetX, targetY, OBSTACLE_WIDTH, OBSTACLE_HEIGHT, {
          isStatic: true,
          render: {
            visible: false
          }
        });
        Matter.World.add(this._world, [this._topBody, this._bottomBody]);
      }

      Obstacle.prototype.getIsPast = function(playerX) {
        if (!this._isPast && this._topBody.position.x <= playerX) {
          this._isPast = true;
          return true;
        } else {
          return false;
        }
      };

      Obstacle.prototype.getPositionX = function() {
        return this._topBody.position.x;
      };

      Obstacle.prototype.getPositionY = function() {
        return {
          top: this._topBody.position.y,
          bottom: this._bottomBody.position.y
        };
      };

      Obstacle.prototype.getId = function() {
        return {
          top: this._topBody.id,
          bottom: this._bottomBody.id
        };
      };

      Obstacle.prototype.update = function() {
        Matter.Body.translate(this._topBody, {
          x: -SCROLL_SPEED,
          y: 0
        });
        return Matter.Body.translate(this._bottomBody, {
          x: -SCROLL_SPEED,
          y: 0
        });
      };

      Obstacle.prototype.remove = function() {
        Matter.World.remove(this._world, this._topBody);
        return Matter.World.remove(this._world, this._bottomBody);
      };

      return Obstacle;

    })();
    view.View = (function() {
      function View(element) {
        var geometry, material, plane, texture;
        this._scene = null;
        this._camera = null;
        this._renderer = null;
        this._intervalId;
        this._player = null;
        this._ceiling = null;
        this._floor = null;
        this._obstacleArr = [];
        this._scene = new THREE.Scene();
        geometry = new THREE.PlaneGeometry(STAGE_WIDTH, STAGE_HEIGHT);
        texture = new THREE.ImageUtils.loadTexture("./images/bg.png");
        material = new THREE.MeshBasicMaterial({
          map: texture
        });
        plane = new THREE.Mesh(geometry, material);
        plane.castShadow = false;
        plane.position.set(0, 0, -STAGE_DEPTH / 2);
        this._scene.add(plane);
        geometry = new THREE.PlaneGeometry(STAGE_WIDTH * 2, STAGE_DEPTH);
        texture = new THREE.ImageUtils.loadTexture("./images/floor.png");
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(40, 20);
        material = new THREE.MeshBasicMaterial({
          map: texture
        });
        this._ceiling = new THREE.Mesh(geometry, material);
        this._ceiling.castShadow = false;
        this._ceiling.position.set(0, STAGE_HEIGHT / 2, 0);
        this._ceiling.rotation.x = 90 * Math.PI / 180;
        this._scene.add(this._ceiling);
        geometry = new THREE.PlaneGeometry(STAGE_WIDTH * 2, STAGE_DEPTH);
        texture = new THREE.ImageUtils.loadTexture("./images/floor.png");
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(40, 20);
        material = new THREE.MeshBasicMaterial({
          map: texture
        });
        this._floor = new THREE.Mesh(geometry, material);
        this._floor.castShadow = false;
        this._floor.position.set(0, -STAGE_HEIGHT / 2, 0);
        this._floor.rotation.x = -90 * Math.PI / 180;
        this._scene.add(this._floor);
        this._camera = new THREE.PerspectiveCamera(60, STAGE_WIDTH / STAGE_HEIGHT, 1, STAGE_DEPTH * 2);
        this._camera.position.set(0, 0, STAGE_DEPTH * 1.5);
        this._renderer = new THREE.WebGLRenderer({
          antialias: false
        });
        this._renderer.shadowMapEnabled = false;
        this._renderer.setSize(STAGE_WIDTH, STAGE_HEIGHT);
        this._renderer.setClearColor(0x4f7eff, 1);
        document.getElementById(element).appendChild(this._renderer.domElement);
        this._intervalId = setInterval((function(_this) {
          return function() {
            return _this._renderer.render(_this._scene, _this._camera);
          };
        })(this), FPS);
      }

      View.prototype.updatePosition = function(params) {
        var arr, isExist, obstacle, obstacleInfo, obstacleX, obstacleY, playerAngle, playerX, playerY, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        if (params.player) {
          if (!this._player) {
            this._player = new view.Player(this._scene);
          }
          playerX = params.player.x - (STAGE_WIDTH / 2) || 0;
          playerY = -(params.player.y - (STAGE_HEIGHT / 2)) || 0;
          playerAngle = -params.player.angle || 0;
          this._player.setPosition(playerX, playerY, playerAngle);
          this._camera.position.y = playerY * 0.4;
        } else if (!params.player) {
          if (this._player) {
            this._player.remove();
            this._player = null;
          }
        }
        _ref = params.obstacleArr;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          obstacleInfo = _ref[_i];
          obstacleX = obstacleInfo.x - (STAGE_WIDTH / 2) || 0;
          obstacleY = -(obstacleInfo.y - (STAGE_HEIGHT / 2)) || 0;
          isExist = false;
          _ref1 = this._obstacleArr;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            obstacle = _ref1[_j];
            if (obstacleInfo.id === obstacle.getId()) {
              isExist = true;
              obstacle.setPosition(obstacleX, obstacleY);
            }
          }
          if (!isExist) {
            obstacle = new view.Obstacle(this._scene, obstacleInfo.id);
            obstacle.setPosition(obstacleX, obstacleY);
            this._obstacleArr.push(obstacle);
          }
        }
        arr = [];
        isExist = false;
        _ref2 = this._obstacleArr;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          obstacle = _ref2[_k];
          _ref3 = params.obstacleArr;
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            obstacleInfo = _ref3[_l];
            if (obstacleInfo.id === obstacle.getId()) {
              isExist = true;
            }
          }
          if (isExist) {
            arr.push(obstacle);
          } else {
            obstacle.remove();
          }
        }
        this._obstacleArr = arr;
        this._floor.position.x = -(params.scroll % (STAGE_WIDTH / 4));
        return this._ceiling.position.x = -(params.scroll % (STAGE_WIDTH / 4));
      };

      View.prototype.jumpPlayer = function() {
        return this._player.jump();
      };

      return View;

    })();
    view.Player = (function() {
      function Player(scene) {
        var geometry, material;
        this._scene = scene;
        this._mesh = null;
        this._texture = null;
        this._intervalId = null;
        geometry = new THREE.PlaneGeometry(PLAYER_WIDTH, PLAYER_HEIGHT);
        this._texture = new THREE.ImageUtils.loadTexture("./images/gesso.png");
        this._texture.wrapS = this._texture.wrapT = THREE.RepeatWrapping;
        this._texture.repeat.set(1 / 2, 1);
        this._texture.offset.x = 1;
        material = new THREE.MeshBasicMaterial({
          map: this._texture
        });
        material.transparent = true;
        this._mesh = new THREE.Mesh(geometry, material);
        this._mesh.castShadow = false;
        this._scene.add(this._mesh);
      }

      Player.prototype.setPosition = function(x, y, rotation) {
        this._mesh.position.set(x, y, 0);
        return this._mesh.rotation.z = rotation;
      };

      Player.prototype.jump = function() {
        this._texture.offset.x = 1 / 2;
        if (this._intervalId) {
          clearTimeout(this._intervalId);
        }
        return this._intervalId = setTimeout((function(_this) {
          return function() {
            return _this._texture.offset.x = 1;
          };
        })(this), 100);
      };

      Player.prototype.remove = function() {
        this._scene.remove(this._mesh);
        return this._mesh = null;
      };

      return Player;

    })();
    view.Obstacle = (function() {
      function Obstacle(scene, id) {
        var geometry, material, mesh, mesh2, mesh3, texture;
        this._scene = scene;
        this._id = id;
        this._mesh = null;
        geometry = new THREE.CylinderGeometry(OBSTACLE_WIDTH / 2.5, OBSTACLE_WIDTH / 2.5, OBSTACLE_HEIGHT - 20, 16, 1, true);
        mesh = new THREE.Mesh(geometry);
        geometry = new THREE.TorusGeometry((OBSTACLE_WIDTH / 2) - 10, 20, 16, 16);
        mesh2 = new THREE.Mesh(geometry);
        mesh2.rotation.x = Math.PI / 2;
        mesh2.rotation.z = Math.PI / 2;
        mesh2.position.set(0, (OBSTACLE_HEIGHT / 2) - 20, 0);
        mesh3 = new THREE.Mesh(geometry);
        mesh3.rotation.x = Math.PI / 2;
        mesh3.rotation.z = Math.PI / 2;
        mesh3.position.set(0, -(OBSTACLE_HEIGHT / 2) + 20, 0);
        geometry = new THREE.Geometry();
        THREE.GeometryUtils.merge(geometry, mesh);
        THREE.GeometryUtils.merge(geometry, mesh2);
        THREE.GeometryUtils.merge(geometry, mesh3);
        texture = new THREE.ImageUtils.loadTexture("./images/clay-pipe.png");
        material = new THREE.MeshBasicMaterial({
          map: texture
        });
        this._mesh = new THREE.Mesh(geometry, material);
        this._mesh = new THREE.Mesh(geometry, material);
        this._mesh.castShadow = false;
        this._scene.add(this._mesh);
      }

      Obstacle.prototype.getId = function() {
        return this._id;
      };

      Obstacle.prototype.setPosition = function(x, y) {
        return this._mesh.position.set(x, y, 0);
      };

      Obstacle.prototype.remove = function() {
        this._scene.remove(this._mesh);
        return this._mesh = null;
      };

      return Obstacle;

    })();
    Panel = (function() {
      function Panel() {
        this._$panelIntro = $("#js-panelIntro");
        this._$panelGame = $("#js-panelGame");
        this._$panelOutro = $("#js-panelOutro");
      }

      Panel.prototype.setIntroScene = function() {
        this._$panelIntro.css({
          display: "block"
        });
        this._$panelGame.css({
          display: "none"
        });
        return this._$panelOutro.css({
          display: "none"
        });
      };

      Panel.prototype.setGameScene = function() {
        this._$panelIntro.css({
          display: "none"
        });
        this._$panelGame.css({
          display: "block"
        });
        return this._$panelOutro.css({
          display: "none"
        });
      };

      Panel.prototype.setOutroScene = function() {
        this._$panelIntro.css({
          display: "none"
        });
        this._$panelGame.css({
          display: "block"
        });
        return this._$panelOutro.css({
          display: "block"
        });
      };

      Panel.prototype.setCount = function(num) {
        return this._$panelGame.text(num);
      };

      return Panel;

    })();
    Sound = (function() {
      function Sound() {
        this._$soundClick = $("#" + ID_SOUND_CLICK);
        this._$soundFailure = $("#" + ID_SOUND_FAILURE);
        this._$soundJump = $("#" + ID_SOUND_JUMP);
        this._$soundCountUp = $("#" + ID_SOUND_COUNTUP);
      }

      Sound.prototype.play = function(id) {
        var target;
        target = null;
        if (id === ID_SOUND_CLICK) {
          target = this._$soundClick.get(0);
        } else if (id === ID_SOUND_FAILURE) {
          target = this._$soundFailure.get(0);
        } else if (id === ID_SOUND_JUMP) {
          target = this._$soundJump.get(0);
        } else if (id === ID_SOUND_COUNTUP) {
          target = this._$soundCountUp.get(0);
        }
        target.currentTime = 0;
        target.volume = 0.2;
        return target.play();
      };

      return Sound;

    })();

    /*
    アクション
     */
    $html.on("keydown", function() {
      return main.onTapScreen();
    });
    $body.on("touchstart", function() {
      return main.onTapScreen();
    });
    onResize = (function(_this) {
      return function() {
        var size;
        if ($window.height() < $window.width()) {
          size = $window.height();
        } else {
          size = $window.width();
        }
        $("#js-game").css({
          position: "absolute",
          top: Math.floor(($window.height() - size) / 2),
          left: Math.floor(($window.width() - size) / 2),
          height: size,
          width: size
        });
        $("#js-panelIntro").css({
          position: "absolute",
          top: Math.floor((size - 100) / 2),
          left: Math.floor((size - 300) / 2)
        });
        $("#js-panelGame").css({
          position: "absolute",
          top: 20,
          left: Math.floor((size - 100) / 2)
        });
        return $("#js-panelOutro").css({
          position: "absolute",
          top: Math.floor((size - 100) / 2),
          left: Math.floor((size - 300) / 2)
        });
      };
    })(this);
    onResize();
    $(window).on("resize", onResize);
    main = new Main();
    return main.start();
  });

}).call(this);

//# sourceMappingURL=index.map
